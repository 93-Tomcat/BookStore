1、在项目中使用Filter
	> 1.1 所有请求： post请求乱码问题
		CharacterEncodingFilter
		
	> 1.2 所有的访问OrderServlet的请求：登录验证
		LoginFilter
			拦截验证访问OrderServlet的请求
	> 1.3 事务处理(多个sql操作要么一起成功或者一起失败，可以看做是一个整体 事务)
		问题：
			结账操作，如果订单保存失败，由于BaseDao中所有的方法都捕获异常了，异常不会导致代码中断执行
			继续向下执行，订单项保存时由于外键关联订单，订单项也保存失败，异常也被处理了
			代码继续执行，更新图书的销量库存，可以直接更新成功
			订单创建失败，但是图书销量库存却修改了

		- 修改了JDBCTools的获取数据库连接和释放连接的方法
			获取连接：
				判断该线程是第一次获取连接还是第N次获取连接
				如果第一次新创建连接并和线程对象绑定
				如果是第N次，直接返回之前绑定过的连接对象
			关闭连接：
				关闭连接并且移除map中没用的数据
		- 创建TransactionFilter：处理事务， 将每个访问服务器的请求看做是一个完整的事务进行处理(服务器每个请求会分配一个线程处理)
			chain.doFilter方法放行时，我们使用了捕获，希望放行中执行的所有操作如果有异常不要自己处理交给TransactionFilter处理
			注意：
				1. BaseDao中的所有异常都需要转为运行时异常抛出
				2. BaseServlet中的异常需要转为运行时异常抛出
				3. 500的原因：自己的代码出现了异常没有处理
					事务Filter 默认捕获的异常时sql异常，BaseServlet抛出的却是运行时异常，捕获不了
					解决：事务Filter中捕获最大异常
				4. 创建错误页面，在出现异常时给用户提示
				5、BaseDao中所有的数据库连接代码都删除，数据库连接统一在事务Filter中管理
				6、修改后的所有的异常都交给事务Filter处理
					但是有些异常：像注册失败，我们希望自己使用异常的结果，不要交给事务filter
							这些异常我们自己捕获处理即可
							UserDaoImpl.saveUser方法中自己处理异常
2、在项目中使用AJAX